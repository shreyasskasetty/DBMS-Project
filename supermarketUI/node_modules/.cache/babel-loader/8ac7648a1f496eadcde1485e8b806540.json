{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/home/shreyas/DBMS-Project/supermarketUI/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _createClass = require(\"/home/shreyas/DBMS-Project/supermarketUI/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/home/shreyas/DBMS-Project/supermarketUI/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _classCallCheck = require(\"/home/shreyas/DBMS-Project/supermarketUI/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _possibleConstructorReturn = require(\"/home/shreyas/DBMS-Project/supermarketUI/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/shreyas/DBMS-Project/supermarketUI/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/shreyas/DBMS-Project/supermarketUI/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _wrapNativeSuper = require(\"/home/shreyas/DBMS-Project/supermarketUI/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapNativeSuper\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar events_1 = require(\"events\");\n\nvar child_process_1 = require(\"child_process\");\n\nvar os_1 = require(\"os\");\n\nvar path_1 = require(\"path\");\n\nvar fs_1 = require(\"fs\");\n\nvar util_1 = require(\"util\");\n\nfunction toArray(source) {\n  if (typeof source === 'undefined' || source === null) {\n    return [];\n  } else if (!Array.isArray(source)) {\n    return [source];\n  }\n\n  return source;\n}\n/**\r\n * adds arguments as properties to obj\r\n */\n\n\nfunction extend(obj) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  Array.prototype.slice.call(arguments, 1).forEach(function (source) {\n    if (source) {\n      for (var key in source) {\n        obj[key] = source[key];\n      }\n    }\n  });\n  return obj;\n}\n/**\r\n * gets a random int from 0-10000000000\r\n */\n\n\nfunction getRandomInt() {\n  return Math.floor(Math.random() * 10000000000);\n}\n\nvar PythonShellError =\n/*#__PURE__*/\nfunction (_Error) {\n  _inherits(PythonShellError, _Error);\n\n  function PythonShellError() {\n    _classCallCheck(this, PythonShellError);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(PythonShellError).apply(this, arguments));\n  }\n\n  return PythonShellError;\n}(_wrapNativeSuper(Error));\n\nexports.PythonShellError = PythonShellError;\n/**\r\n * An interactive Python shell exchanging data through stdio\r\n * @param {string} script    The python script to execute\r\n * @param {object} [options] The launch options (also passed to child_process.spawn)\r\n * @constructor\r\n */\n\nvar PythonShell =\n/*#__PURE__*/\nfunction (_events_1$EventEmitte) {\n  _inherits(PythonShell, _events_1$EventEmitte);\n\n  /**\r\n   * spawns a python process\r\n   * @param scriptPath path to script. Relative to current directory or options.scriptFolder if specified\r\n   * @param options\r\n   */\n  function PythonShell(scriptPath, options) {\n    var _this;\n\n    _classCallCheck(this, PythonShell);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(PythonShell).call(this));\n    /**\r\n     * returns either pythonshell func (if val string) or custom func (if val Function)\r\n     */\n\n    function resolve(type, val) {\n      if (typeof val === 'string') {\n        // use a built-in function using its name\n        return PythonShell[type][val];\n      } else if (typeof val === 'function') {\n        // use a custom function\n        return val;\n      }\n    }\n\n    if (scriptPath.trim().length == 0) throw Error(\"scriptPath cannot be empty! You must give a script for python to run\");\n\n    var self = _assertThisInitialized(_assertThisInitialized(_this));\n\n    var errorData = '';\n    events_1.EventEmitter.call(_assertThisInitialized(_assertThisInitialized(_this)));\n    options = extend({}, PythonShell.defaultOptions, options);\n    var pythonPath;\n\n    if (!options.pythonPath) {\n      pythonPath = PythonShell.defaultPythonPath;\n    } else pythonPath = options.pythonPath;\n\n    var pythonOptions = toArray(options.pythonOptions);\n    var scriptArgs = toArray(options.args);\n    _this.scriptPath = path_1.join(options.scriptPath || '', scriptPath);\n    _this.command = pythonOptions.concat(_this.scriptPath, scriptArgs);\n    _this.mode = options.mode || 'text';\n    _this.formatter = resolve('format', options.formatter || _this.mode);\n    _this.parser = resolve('parse', options.parser || _this.mode);\n    _this.stderrParser = resolve('parse', options.stderrParser || _this.mode);\n    _this.terminated = false;\n    _this.childProcess = child_process_1.spawn(pythonPath, _this.command, options);\n    ['stdout', 'stdin', 'stderr'].forEach(function (name) {\n      self[name] = self.childProcess[name];\n      self.parser && self[name] && self[name].setEncoding(options.encoding || 'utf8');\n    }); // parse incoming data on stdout\n\n    if (_this.parser && _this.stdout) {\n      _this.stdout.on('data', _this.receive.bind(_assertThisInitialized(_assertThisInitialized(_this))));\n    } // listen to stderr and emit errors for incoming data\n\n\n    if (_this.stderr) {\n      _this.stderr.on('data', function (data) {\n        errorData += '' + data;\n        self.receiveStderr(data);\n      });\n\n      _this.stderr.on('end', function () {\n        self.stderrHasEnded = true;\n        terminateIfNeeded();\n      });\n    } else {\n      self.stderrHasEnded = true;\n    }\n\n    if (_this.stdout) {\n      _this.stdout.on('end', function () {\n        self.stdoutHasEnded = true;\n        terminateIfNeeded();\n      });\n    } else {\n      self.stdoutHasEnded = true;\n    }\n\n    _this.childProcess.on('exit', function (code, signal) {\n      self.exitCode = code;\n      self.exitSignal = signal;\n      terminateIfNeeded();\n    });\n\n    function terminateIfNeeded() {\n      if (!self.stderrHasEnded || !self.stdoutHasEnded || self.exitCode == null && self.exitSignal == null) return;\n      var err;\n\n      if (self.exitCode && self.exitCode !== 0) {\n        if (errorData) {\n          err = self.parseError(errorData);\n        } else {\n          err = new PythonShellError('process exited with code ' + self.exitCode);\n        }\n\n        err = extend(err, {\n          executable: pythonPath,\n          options: pythonOptions.length ? pythonOptions : null,\n          script: self.scriptPath,\n          args: scriptArgs.length ? scriptArgs : null,\n          exitCode: self.exitCode\n        }); // do not emit error if only a callback is used\n\n        if (self.listeners('error').length || !self._endCallback) {\n          self.emit('error', err);\n        }\n      }\n\n      self.terminated = true;\n      self.emit('close');\n      self._endCallback && self._endCallback(err, self.exitCode, self.exitSignal);\n    }\n\n    ;\n    return _this;\n  }\n  /**\r\n   * checks syntax without executing code\r\n   * @param {string} code\r\n   * @returns {Promise} rejects w/ stderr if syntax failure\r\n   */\n\n\n  _createClass(PythonShell, [{\n    key: \"parseError\",\n\n    /**\r\n     * Parses an error thrown from the Python process through stderr\r\n     * @param  {string|Buffer} data The stderr contents to parse\r\n     * @return {Error} The parsed error with extended stack trace when traceback is available\r\n     */\n    value: function parseError(data) {\n      var text = '' + data;\n      var error;\n\n      if (/^Traceback/.test(text)) {\n        // traceback data is available\n        var lines = ('' + data).trim().split(new RegExp(os_1.EOL, 'g'));\n        var exception = lines.pop();\n        error = new PythonShellError(exception);\n        error.traceback = data; // extend stack trace\n\n        error.stack += os_1.EOL + '    ----- Python Traceback -----' + os_1.EOL + '  ';\n        error.stack += lines.slice(1).join(os_1.EOL + '  ');\n      } else {\n        // otherwise, create a simpler error with stderr contents\n        error = new PythonShellError(text);\n      }\n\n      return error;\n    }\n  }, {\n    key: \"send\",\n\n    /**\r\n     * Sends a message to the Python shell through stdin\r\n     * Override this method to format data to be sent to the Python process\r\n     * @param {string|Object} data The message to send\r\n     * @returns {PythonShell} The same instance for chaining calls\r\n     */\n    value: function send(message) {\n      if (!this.stdin) throw new Error(\"stdin not open for writting\");\n      var data = this.formatter ? this.formatter(message) : message;\n      if (this.mode !== 'binary') data += os_1.EOL;\n      this.stdin.write(data);\n      return this;\n    }\n  }, {\n    key: \"receive\",\n\n    /**\r\n     * Parses data received from the Python shell stdout stream and emits \"message\" events\r\n     * This method is not used in binary mode\r\n     * Override this method to parse incoming data from the Python process into messages\r\n     * @param {string|Buffer} data The data to parse into messages\r\n     */\n    value: function receive(data) {\n      return this.receiveInternal(data, 'message');\n    }\n  }, {\n    key: \"receiveStderr\",\n\n    /**\r\n     * Parses data received from the Python shell stderr stream and emits \"stderr\" events\r\n     * This method is not used in binary mode\r\n     * Override this method to parse incoming logs from the Python process into messages\r\n     * @param {string|Buffer} data The data to parse into messages\r\n     */\n    value: function receiveStderr(data) {\n      return this.receiveInternal(data, 'stderr');\n    }\n  }, {\n    key: \"receiveInternal\",\n    value: function receiveInternal(data, emitType) {\n      var self = this;\n      var parts = ('' + data).split(new RegExp(os_1.EOL, 'g'));\n\n      if (parts.length === 1) {\n        // an incomplete record, keep buffering\n        this._remaining = (this._remaining || '') + parts[0];\n        return this;\n      }\n\n      var lastLine = parts.pop(); // fix the first line with the remaining from the previous iteration of 'receive'\n\n      parts[0] = (this._remaining || '') + parts[0]; // keep the remaining for the next iteration of 'receive'\n\n      this._remaining = lastLine;\n      parts.forEach(function (part) {\n        if (emitType == 'message') self.emit(emitType, self.parser(part));else if (emitType == 'stderr') self.emit(emitType, self.stderrParser(part));\n      });\n      return this;\n    }\n    /**\r\n     * Closes the stdin stream, which should cause the process to finish its work and close\r\n     * @returns {PythonShell} The same instance for chaining calls\r\n     */\n\n  }, {\n    key: \"end\",\n    value: function end(callback) {\n      if (this.childProcess.stdin) {\n        this.childProcess.stdin.end();\n      }\n\n      this._endCallback = callback;\n      return this;\n    }\n  }, {\n    key: \"terminate\",\n\n    /**\r\n     * Closes the stdin stream, which should cause the process to finish its work and close\r\n     * @returns {PythonShell} The same instance for chaining calls\r\n     */\n    value: function terminate(signal) {\n      this.childProcess.kill(signal);\n      this.terminated = true;\n      return this;\n    }\n  }], [{\n    key: \"checkSyntax\",\n    value: function checkSyntax(code) {\n      return __awaiter(this, void 0, void 0,\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        var _this2 = this;\n\n        var randomInt, filePath;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                randomInt = getRandomInt();\n                filePath = os_1.tmpdir() + path_1.sep + \"pythonShellSyntaxCheck\".concat(randomInt, \".py\"); // todo: replace this with util.promisify (once we no longer support node v7)\n\n                return _context.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  fs_1.writeFile(filePath, code, function (err) {\n                    if (err) reject(err);\n                    resolve(_this2.checkSyntaxFile(filePath));\n                  });\n                }));\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n    }\n  }, {\n    key: \"getPythonPath\",\n    value: function getPythonPath() {\n      return this.defaultOptions.pythonPath ? this.defaultOptions.pythonPath : this.defaultPythonPath;\n    }\n    /**\r\n     * checks syntax without executing code\r\n     * @param {string} filePath\r\n     * @returns {Promise} rejects w/ stderr if syntax failure\r\n     */\n\n  }, {\n    key: \"checkSyntaxFile\",\n    value: function checkSyntaxFile(filePath) {\n      return __awaiter(this, void 0, void 0,\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2() {\n        var pythonPath, compileCommand;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                pythonPath = this.getPythonPath();\n                compileCommand = \"\".concat(pythonPath, \" -m py_compile \").concat(filePath);\n                return _context2.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  child_process_1.exec(compileCommand, function (error, stdout, stderr) {\n                    if (error == null) resolve();else reject(stderr);\n                  });\n                }));\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n    /**\r\n     * Runs a Python script and returns collected messages\r\n     * @param  {string}   scriptPath   The path to the script to execute\r\n     * @param  {Options}   options  The execution options\r\n     * @param  {Function} callback The callback function to invoke with the script results\r\n     * @return {PythonShell}       The PythonShell instance\r\n     */\n\n  }, {\n    key: \"run\",\n    value: function run(scriptPath, options, callback) {\n      var pyshell = new PythonShell(scriptPath, options);\n      var output = [];\n      return pyshell.on('message', function (message) {\n        output.push(message);\n      }).end(function (err) {\n        if (err) return callback(err);\n        return callback(null, output.length ? output : null);\n      });\n    }\n  }, {\n    key: \"runString\",\n\n    /**\r\n     * Runs the inputted string of python code and returns collected messages. DO NOT ALLOW UNTRUSTED USER INPUT HERE!\r\n     * @param  {string}   code   The python code to execute\r\n     * @param  {Options}   options  The execution options\r\n     * @param  {Function} callback The callback function to invoke with the script results\r\n     * @return {PythonShell}       The PythonShell instance\r\n     */\n    value: function runString(code, options, callback) {\n      // put code in temp file\n      var randomInt = getRandomInt();\n      var filePath = os_1.tmpdir + path_1.sep + \"pythonShellFile\".concat(randomInt, \".py\");\n      fs_1.writeFileSync(filePath, code);\n      return PythonShell.run(filePath, options, callback);\n    }\n  }, {\n    key: \"getVersion\",\n    value: function getVersion(pythonPath) {\n      if (!pythonPath) pythonPath = this.getPythonPath();\n      var execPromise = util_1.promisify(child_process_1.exec);\n      return execPromise(pythonPath + \" --version\");\n    }\n  }, {\n    key: \"getVersionSync\",\n    value: function getVersionSync(pythonPath) {\n      if (!pythonPath) pythonPath = this.getPythonPath();\n      return child_process_1.execSync(pythonPath + \" --version\").toString();\n    }\n  }]);\n\n  return PythonShell;\n}(events_1.EventEmitter); // starting 2020 python2 is deprecated so we choose 3 as default\n\n\nPythonShell.defaultPythonPath = process.platform != \"win32\" ? \"python3\" : \"py\";\nPythonShell.defaultOptions = {}; //allow global overrides for options\n// built-in formatters\n\nPythonShell.format = {\n  text: function toText(data) {\n    if (!data) return '';else if (typeof data !== 'string') return data.toString();\n    return data;\n  },\n  json: function toJson(data) {\n    return JSON.stringify(data);\n  }\n}; //built-in parsers\n\nPythonShell.parse = {\n  text: function asText(data) {\n    return data;\n  },\n  json: function asJson(data) {\n    return JSON.parse(data);\n  }\n};\nexports.PythonShell = PythonShell;\n;","map":null,"metadata":{},"sourceType":"script"}